var relearn_searchindex = [
  {
    "breadcrumb": "Préalables",
    "content": "Structure d’un document HTML Un document HTML se compose d’éléments organisés comme une hiérarchie ayant la forme d’une arbre inversé. Chaque noeud dans cet arbre correspond à un type d’élément HTML qui peut avoir plusieurs noeuds enfants et au maximum un parent. Seule la racine (le noeud document, au sommet de la hiérarchie) n’a pas de parent.\nL’exemple suivant correspond à un document HTML simple:\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cscript src=\"lib.js\"\u003e\u003c/script\u003e \u003ctitle\u003ePage perso\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eBienvenue\u003c/h1\u003e \u003cdiv\u003eVoici du texte\u003c/div\u003e \u003ca href=\"https://www.google.com\"\u003eVoici un lien\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e Ce qui correspond au modèle suivant:\nObjet document Javascript comprend un objet nommé document qui permet d’accéder aux informations du DOM, de modifier des valeurs d’attributs ou du texte, d’ajouter, de supprimer ou de déplacer des éléments HTML, etc.\nL’objet document comprend plusieurs méthodes pour accéder aux éléments du DOM; Parmi celles-ci:\ngetElementById()\nRetourne l’élément HTML dont l’attribut id correspond à la valeur passée.\ngetElementByTagName()\nRetourne une collection d’éléments HTML dont les noms correspondent à la valeur passée.\ngetElementByClassName()\nRetourne une collection d’éléments HTML dont les attributs class correspondent à la valeur passée.\nPar exemple pour le code HTML suivant:\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003ch1 class=\"title\"\u003eTitre\u003c/h1\u003e \u003ch2 class=\"title\"\u003eSous-titre\u003c/h2\u003e \u003cdiv\u003e \u003cp id=\"par1\" class=\"parag\"\u003ePremier paragraphe\u003c/p\u003e \u003cp id=\"par2\" class=\"parag\" \u003eDeuxième paragraphe\u003c/p\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e getElementById(\"par1\") retourne l’élément \u003cp\u003e “Premier paragraphe”; getElementsByTagName(\"p\") retourne tous les éléments \u003cp\u003e; getElementsByClassName(\"title\") retourne les éléments \u003ch1\u003e et \u003ch2\u003e. Attention Lorsque ces méthodes retournent plus d’un élément, ceux-ci font partie d’une collection et on doit utiliser une boucle pour accéder à chacun individuellement.\nPropriétés des éléments Les éléments HTML contiennent d’innombrables propriétés et méthodes qu’on peut utiliser pour en modifier le contenu. Ici nous verrons les propriétés innerHTML et style.\nNote Pour la référence complète de l’objet Element du DOM: https://www.w3schools.com/jsref/dom_obj_all.asp.\ninnerHTML Permet d’accéder le contenu HTML d’un élément ou de le modifier. Par exemple, pour le document HTML de l’exemple plus haut:\nlet el = document.getElementById(\"par1\"); el.innerHTML=\"Bonjour\"; Le texte “Premier paragraphe” sera remplacé par “Bonjour”.\nAttention, le texte ainsi inséré est interprété comme du HTML. On peut ainsi modifier indirectement la structure du DOM; par exmeple:\nlet elems = document.getElementsByClassName(\"parag\"); for (let i=0;i\u003celems.length;i++) { elems[i].innerHTML=\"\u003ch1\u003eBonjour\u003c/h1\u003e\"; } Les deux éléments \u003cp\u003e contiendront chacun un élément \u003ch1\u003e ayant le texte “Bonjour”.\nstyle La propriété style permet de changer les attributs de style. Tous les styles qui peuvent être définis par l’attribut HTML “style” ou dans un fichier CSS sont accessibles par javascript. Les noms des styles sont légèrement différents cependant car ils suivent la nomenclature “camelCase”: par exemple, la propriété CSS background-color est appelée backgroundColor dans javascript.\nPar exemple, pour mettre en gras le texte des paragraphes d’un document:\nlet elems = document.getElementsByTagName(\"p\"); for (let i=0;i\u003celems.length;i++) { elems[i].style.fontWeight=\"bold\"; } Note Pour la référence complète des propriétés de style : https://www.w3schools.com/jsref/dom_obj_style.asp\nCSS Il est possible de modifier l’apparence des éléments d’une page directement dans le code HTML en utilisant les attributs de style. Par exemple, pour changer la couleur du texte d’un paragraphe:\n\u003cdiv\u003e \u003cp\u003eTexte normal\u003c/p\u003e \u003cp style=\"color:red\"\u003eTexte rouge\u003c/p\u003e \u003cp style=\"background-color:yellow\"\u003eArrière-plan jaune\u003c/p\u003e \u003c/div\u003e On recommande cependant de regrouper ces propriétés dans un fichier CSS: ceci permet de centraliser les éléments de style et de permettre plus facilement les modifications. Par exemple, si on souhaite que les citations dans un texte soient en italique, sans serif et de couleur grise, on pourra définir une classe nommée quote dans un fichier CSS et y spécifier ces propriétés typographiques, comme suit:\n.quote { font-family: sans-serif; color: grey; font-style: italic; } Par la suite, on attribue la classe quote à l’élément HTML dont on veut modifier le style:\n\u003cp class=\"quote\"\u003eAlea Jacta Est\u003c/p\u003e Pour que le navigateur puisse retrouver le fichier CSS où le style est défini, il faut y ajouter une référence dans le fichier HTML dans un élément \u003clink\u003e. En supposant que le fichier qui contient les styles se nomme styles.css, on aura donc le code HTML suivant:\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003clink href=\"styles.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cp class=\"quote\"\u003eAlea Jacta Est\u003c/p\u003e \u003cp\u003e- Jules César\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Note Une référence complète des propriétés CSS est disponible sur le site https://www.w3schools.com/cssref/index.php.\nExercices Exercice 1 À partir du DOM suivant, faites le fichier HTML correspondant (Nommez votre fichier exercice-dom-1.html) :\nExercice 2 Dans le document exercice-dom-2.html, les éléments ont des attributs id. En utilisant des appels à la fonction getElementById(), remplacez les mots “apple”, “pear” et “banana” par “pomme”, “poire” et “banane”. (vous devez créer le fichier exercice-dom-2.js)\nExercice 3 Dans le document exercice-dom-3.html, certains éléments ont un attribut class. Créez le fichier exercice-dom-3.js et utilisez la fonction getElementsByClass(), pour modifier le style du texte afin que celui-ci utilise la fonte Arial et soit écrit en bleu.\nExercice 4 À partir du document exercice-dom-4.html, définissez la fonction associée au bouton pour basculer en mode sombre en modifiant les styles des éléments HTML. Vous pouvez utiliser le site suivant pour les références aux couleurs : https://htmlcolorcodes.com/.\nLe résultat devrait ressembler à ceci (les titres sont en vert pâle et le texte en gris) :",
    "description": "Structure d’un document HTML Un document HTML se compose d’éléments organisés comme une hiérarchie ayant la forme d’une arbre inversé. Chaque noeud dans cet arbre correspond à un type d’élément HTML qui peut avoir plusieurs noeuds enfants et au maximum un parent. Seule la racine (le noeud document, au sommet de la hiérarchie) n’a pas de parent.\nL’exemple suivant correspond à un document HTML simple:\n\u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cscript src=\"lib.",
    "tags": [],
    "title": "HTML, DOM et CSS",
    "uri": "/0-intro/1-html-dom/index.html"
  },
  {
    "breadcrumb": "Préalables",
    "content": "Chaque fois que l’on souhaite effectuer une tâche répétitive, on utilise des fonctions. En Javascript, il existe plusieurs types de syntaxes pour déclarer une fonction.\nFonctions nommées Une fonction nommée commence par le mot-clé function, suivi du nom de la fonction (dans l’exemple ci-dessous : logCompliment). Le corps de la fonction et ses instructions (i.e. son bloc d’instruction) sont définis entre des accolades :\nfunction logCompliment() { console.log(\"Vous vous débrouilles très bien !\") ; } Une fois la fonction déclarée, vous l’invoquez ou l’appelez pour la voir s’exécuter :\nfunction logCompliment() { console.log(\"Vous vous débrouillez très bien !\") ; } logCompliment() ; Fonctions anonymes Une autre option serait d’utiliser la syntaxe de fonction anonyme, ce qui revient à déclarer la fonction comme une variable :\nconst logCompliment = function() { console.log(\"Vous vous débrouillez très bien !\") ; }; logCompliment(); Le resultat est le même. La seule différence, c’est qu’il n’est pas possible d’invoquer une fonction anonyme avant de la déclarer :\n// Invoquer la fonction avant de la déclarer hey(); // Fonction nommée function hey() { alert(\"hey!\"); } // Invoquer la fonction avant de la déclarer hey(); // Fonction anonyme const hey = function() { alert(\"hey!\"); }; TypeError: hey is not a function Passage d’arguments Une fonction peut prendre un ou plusieurs arguments en entrée :\nconst logCompliment = function(firstName) { console.log(`Vous vous débrouilles très bien, ${firstName}`); }; logCompliment(\"Molly\"); const logCompliment = function(firstName, message) { console.log(`${firstName}: ${message}`); }; logCompliment(\"Molly\", \"Tu es vraiment cool !\"); Retour de fonctions La fonction logCompliment affiche un compliment sur la console, mais le plus souvent, une fonction est utilisée pour retourner une valeur. Pour cela, on utilise le mot-clé return.\nconst createCompliment = function(firstName, message) { return `${prénom} : ${message}` ; } ; createCompliment(\"Molly\", \"You're so cool\") ; console.log(createCompliment(\"You're so cool\", \"Molly\")) ; Arguments par défaut Il est possible d’avoir des valeurs par défaut pour les arguments. Dans le cas ou la valeur n’est pas fournie, la valeur par défaut est utilisée :\nfunction logActivity(name = \"Shane McConkey\", activity = \"skier\") { console.log(`${name} adore ${activity}`); } const defaultPerson = { name: { first: \"Shane\", last: \"McConkey\" }, favActivity: \"skier\" }; function logActivity(person = defaultPerson) { console.log(`${person.name.first} adore ${person.favActivity}`); } Fonctions fléchées Une façon plus “moderne” de déclarer une fonction est d’utiliser la syntaxe des fonctions fléchées. Avec les fonctions fléchées, il est possible de créer des fonctions sans utiliser le mot-clé function. Souvent, il n’est pas non plus nécessaire d’utiliser le mot-clé return.\nFonction anonyme :\nconst lordify = function(firstName) { return `${firstName} de Canterbury`; }; console.log(lordify(\"Dale\")); // Seigneur Dale de Canterbury console.log(lordify(\"Gail\")); // Seigneur Gail de Canterbury Fonction fléchées (syntaxe plus simple et épurée) :\nconst lordify = firstName =\u003e `${firstName} de Canterbury`; Si la fonction possède plus d’un argument, il doivent être entourés de parenthèses :\n// Fonction anonyme const lordify = function(firstName, land) { return `${firstName} de ${land}`; }; // Fonction fléché const lordify = (firstName, land) =\u003e `${firstName} of ${land}`; console.log(lordify(\"Don\", \"Piscataway\")); // Don de Piscataway console.log(lordify(\"Todd\", \"Schenectady\")); // Todd de Schenectady Cette fonction peut tenir sur une seule ligne car il n’y a qu’une seule déclaration à renvoyer. S’il y a plusieurs lignes, il faut utiliser des accolades :\nconst lordify = (firstName, land) =\u003e { if (!firstName) { throw new Error(\"Un prénom doit être fourni\"); } if (!land) { throw new Error(\"Un territoire doit être fourni\"); } return `${firstName} de ${land}`; }; console.log(lordify(\"Kelly\", \"Sonoma\")); // Kelly de Sonoma console.log(lordify(\"Dave\")); // ! JAVASCRIPT ERROR",
    "description": "Chaque fois que l’on souhaite effectuer une tâche répétitive, on utilise des fonctions. En Javascript, il existe plusieurs types de syntaxes pour déclarer une fonction.\nFonctions nommées Une fonction nommée commence par le mot-clé function, suivi du nom de la fonction (dans l’exemple ci-dessous : logCompliment). Le corps de la fonction et ses instructions (i.e. son bloc d’instruction) sont définis entre des accolades :\nfunction logCompliment() { console.log(\"Vous vous débrouilles très bien !",
    "tags": [],
    "title": "Fonctions JS",
    "uri": "/0-intro/2-fonctions-js/index.html"
  },
  {
    "breadcrumb": "Préalables",
    "content": "Javascript dispose de manières alternatives pour exprimer les conditions. Celles-ci sont plus utilisées que la syntaxe if/else traditionnelle.\nOpérateur ternaire Les conditions qui définissent deux alternatives utilisent l’opérateur ternaire, ainsi nommé pare qu’il prend trois opérandes : un pour la condition à évaluer, un pour la cas vrai et un pour le cas faux.\nLa syntaxe est CONDITION ? Cas vrai : Cas faux. Par exemple, les deux structures suivantes sont équivalentes:\nlet i=10; // Condition classique if (i % 2 == 0) { console.log(\"i est pair\"); } else { console.log(\"i est impair\"); } // Opérateur ternaire i % 2 == 0 ? console.log(\"i est pair\") : console.log(\"i est impair\") Opérateur \u0026\u0026 L’opérateur de conjonction (“ET” logique) est aussi utilisé dans les conditions.\nLorsque deux expressions sont reliées par \u0026\u0026, les deux doivent être vraies pour que la conjonction soit vraie. Donc lorsque JavaScript évalue des expressions reliées par \u0026\u0026, il évalue d’abord la première, et si celle-ci est fausse il ne va pas plus loin car nécessairement toute l’expression sera fausse. À l’inverse, si la première expression est vraie, javascript doit évaluer la deuxième pour déterminer si l’ensemble est vrai ou faux.\nLe fait que javascript parcourt ainsi les conjonctions de gauche à droite pour les évaluer nous permet d’utiliser l’opérateur \u0026\u0026 pour exprimer des conditions.\nLa syntaxe est donc : CONDITION \u0026\u0026 Cas vrai. Les deux structures suivantes sont équivalentes:\nlet i=10; // Condition classique if (i % 2 == 0) { console.log(\"i est pair\"); } // Opérateur \u0026\u0026 i % 2 == 0 \u0026\u0026 console.log(\"i est pair\")",
    "description": "Javascript dispose de manières alternatives pour exprimer les conditions. Celles-ci sont plus utilisées que la syntaxe if/else traditionnelle.\nOpérateur ternaire Les conditions qui définissent deux alternatives utilisent l’opérateur ternaire, ainsi nommé pare qu’il prend trois opérandes : un pour la condition à évaluer, un pour la cas vrai et un pour le cas faux.\nLa syntaxe est CONDITION ? Cas vrai : Cas faux. Par exemple, les deux structures suivantes sont équivalentes:",
    "tags": [],
    "title": "Conditions JS",
    "uri": "/0-intro/3-conditions-js/index.html"
  },
  {
    "breadcrumb": "Préalables",
    "content": "Depuis la version 5 de ECMAScript (et surtout avec la version 6), la syntaxe de JavaScript a beaucoup évolué pour aller vers une meilleure cohérence et une meilleure robustesse dans le code produit. Ce chapitre résume les évolutions les plus importantes.\nDéclaration de variable avec let et const (ES6) Le mot-clé var est utilisé en JavaScript pour déclarer des variables.\nvar i = 0; Cependant la notion de déclaration de variable est particulière en JavaScript par rapport à la plupart des autres langages de programmation proches. var n’empêche pas de déclarer à nouveau une variable avec le même nom et la portée des variables est particulière à JavaScript. Si la variable est déclarée au plus haut niveau, il s’agit d’une variable globale mais si elle déclarée ailleurs, sa portée correspond à la fonction dans laquelle elle est déclarée. Cela peut entraîner des effets de bord difficiles à comprendre :\nvar globalVar = \"globale\"; function myFunction() { var localVar = \"locale\"; if (true) { var localVar2 = \"locale 2\"; } console.log(globalVar); console.log(localVar); console.log(localVar2); } myFunction(); // Affiche // globale // locale // locale 2 À la ligne 7, la variable localVar2 est déclarée dans le bloc if mais, contrairement à d’autres langages de programmation, la portée de cette variable est la fonction. Donc il est possible d’accéder à sa valeur à la ligne 11 après le bloc if.\nPour corriger ce comportement tout en maintenant la rétro-compatibilité pour le code existant, ES6 introduit le mot-clé let.\nlet j = 0; Une variable déclarée avec let ne peut pas être déclarée à nouveau et sa portée est limitée au bloc dans lequel elle est déclarée.\nAttention Pour tout nouveau code, il est recommandé d’utiliser let pour déclarer toutes les variables.\nAvec ES6, on dispose également du mot-clé const pour garantir que la déclaration est constante (une fois déclarée, sa valeur ne peut pas être modifiée) :\nconst pi = 3.1416; La structure for … of (ES6) Une nouvelle structure de contrôle for a été ajoutée avec ES6 pour permettre de parcourir les objets itérables. Il s’agit de la structure for ... of\nfor (let v of vowels) { console.log(v); } // Affiche // a // e // i // o // u // y Les tableaux et les chaînes de caractères sont des objets itérables. Il est donc très facile de les parcourir avec cette nouvelle structure de contrôle.\nfor (let i of [1, 2, 3, 4]) { console.log(i); } for (let l of \"Bonjour\") { console.log(l); } Gabarit de chaîne de caractères (ES6) ES6 introduit les gabarits de chaîne de caractères (template string) pour formater plus facilement des données dans des chaînes de caractères. Plutôt que d’utiliser l’opérateur + de concaténation :\nlet a = 1; let b = 2; let message = \"La somme de \" + a + \" et de \" + b + \" est \" + (a + b) + \".\"; On peut utiliser le caractère ` pour délimiter la chaîne de caractères et préciser les noms des variables avec ${} :\nlet a = 1; let b = 2; let message = `La somme de ${a} et de ${b} est ${a + b}`; La syntaxe est plus concise et bien plus lisible. La valeur donnée avec ${} peut être une expression complète : un appel de fonction, l’attribut d’un objet…\nlet message = `La circonférence d'un cercle de rayon 3 est ${(2 * Math.PI * 3).toFixed(3)}`; console.log(message); // Affiche La circonférence d'un cercle de rayon 3 est 18.850 L’utilisation du caractère ` pour délimiter une chaîne de caractères permet également d’écrire cette chaîne sur plusieurs lignes :\nlet message = `Ceci est un message. Ce message est sur plusieurs lignes. Il sera affiché également sur plusieurs lignes.`; console.log(message); // Affiche : // Ceci est un message. // Ce message est sur plusieurs lignes. // Il sera affiché également sur plusieurs lignes. Valeur par défaut des paramètres (ES6) Depuis ES6, il est possible de fournir des valeurs par défaut aux paramètres d’une fonction.\nfunction sayHi(person, message = \"Bonjour\") { console.log(message, person); } saluer(\"David\"); // Affiche Bonjour David saluer(\"David\", \"Bonsoir\"); // Affiche Bonsoir David Le paramètre de reste (Spread Operator) (ES6) Avec l’opérateur ..., il est possible de déclarer une liste quelconque de paramètres correspondant au reste des paramètres. Cette liste sera vue comme un tableau à l’intérieur de la fonction\nfunction add(x1, x2, ...others) { let result = x1 + x2; for (let n of others) { result += n; } return result; } console.log(add(1, 2)); // Affiche 3 console.log(add(1, 2, 4)); // Affiche 7 console.log(add(1, 2, 4, 8)); // Affiche 15 La décomposition de tableaux (ES6) L’opérateur ... sert également à la décomposition de tableau qui permet de passer les paramètres à l’appel d’une fonction sous la forme d’un tableau.\nlet args = [2, 3]; function add(x, y) { console.log(x + y); } add(...args); // Affiche 5 L’affectation de tableau par décomposition (ES6) L’affectation par décomposition (destructuring assignment) permet de réaliser des affectations multiples à partir d’un tableau.\nOn peut déclarer un tableau de variables à gauche de l’affectation.\nconst arr = [1, 2, 3]; let [a, b, c] = arr; console.log(a); // Affiche 1 console.log(b); // Affiche 2 console.log(c); // Affiche 3 Nous pouvons utiliser cette syntaxe pour intervertir la valeur de deux variables.\nlet a = 1: let b = 2: [a, b] = [b, a]; // a vaut 2 et b vaut 1 Le tableau à gauche de l’affectation peut avoir une taille différent du tableau à droite de l’affectation. Si le tableau à gauche est plus petit, les éléments en plus à droite ne sont pas pris en compte.\nlet [a, b] = [1, 2, 3, 4]; // a vaut 1 et b vaut 2 Si le tableau à gauche de l’affectation est plus grand, les éléments en plus reçoivent la valeur undefined.\nlet [a, b, c, d] = [1, 2]; // a vaut 1, b vaut 2, c et d valent undefined On peut utiliser l’opérateur de reste ... pour affecter à une variable tous les éléments restant :\nlet [a, ...b] = [1, 2, 3, 4]; // a vaut 1 et b vaut [2, 3, 4] Affectation d’objet par décomposition (ES6) L’affectation par décomposition (destructuring assignment) permet également de réaliser des affectations multiples à partir d’un objet. Dans ce cas, le nom des variables à gauche de l’affectation correspondent au nom des propriétés de l’objet.\nconst person = { firstName: \"David\", lastName: \"Gayerie\" }; let {firstName, lastName} = person; console.log(firstName); // Affiche David console.log(lastName); // Affiche Gayerie Comme pour l’affectation de tableau par décomposition, on peut spécifier moins de variables à gauche ou plus de variables ou utiliser l’opérateur de reste … pour affecter les propriétés restantes sous la forme d’un nouvel objet.\nconst person = { firstName: \"David\", lastName: \"Gayerie\", height: 174 }; let {firstName, lastName} = person; // firstName vaut \"David\" et lastName vaut \"Gayerie\" const person = { lastName: \"Gayerie\", }; let {firstName, lastName} = person; // nom vaut \"David\" et prenom vaut undefined const person = { firstName: \"David\", lastName: \"Gayerie\", height: 174 }; let {height, ...fullName} = personne; // height vaut 174 // fullName vaut {firstName: \"David\", lastName: \"Gayerie\"}",
    "description": "Depuis la version 5 de ECMAScript (et surtout avec la version 6), la syntaxe de JavaScript a beaucoup évolué pour aller vers une meilleure cohérence et une meilleure robustesse dans le code produit. Ce chapitre résume les évolutions les plus importantes.\nDéclaration de variable avec let et const (ES6) Le mot-clé var est utilisé en JavaScript pour déclarer des variables.\nvar i = 0; Cependant la notion de déclaration de variable est particulière en JavaScript par rapport à la plupart des autres langages de programmation proches.",
    "tags": [],
    "title": "JS depuis ES5",
    "uri": "/0-intro/5-es5-js/index.html"
  },
  {
    "breadcrumb": "Préalables",
    "content": "Définition La programmation fonctionnelle est un paradigme de programmation qui insiste sur l’évaluation d’appel de fonctions plutôt que sur l’utilisation de variables et de blocs imbriqués (for, if…).\nLes fonctions ont toujours été des objets de plein droit en JavaScript. Il est par exemple possible de créer des fonctions anonymes et de les affecter à des variables ou de les passer en paramètre d’autres fonctions.\nImpératif vs déclaratif La programmation fonctionnelle fait partie d’un paradigme de programmation plus large : la programmation déclarative.\nLa programmation déclarative est un style de programmation dans lequel les applications sont structurées de telle sorte à donner la priorité à qu’est-ce qui doit se produire plutôt qu’à comment cela doit se produire.\nUtilisation de .forEach() Une première application de la programmation fonctionnelle consiste à repenser le parcours de boucle sous la forme d’un appel à la méthode Array.forEach à laquelle on passe une fonction à appeler pour chaque élément.\nlet t = [1, 2, 3, 4]; t.forEach(e =\u003e console.log(e)); Le modèle filter/map/reduce Un modèle classique de traitement d’un tableau d’éléments dans une approche fonctionnelle consiste à envisager trois opérations fondamentales :\nfilter : Permet de ne retenir qu’une partie des éléments d’un tableau. map : Permet de changer la nature des éléments lors du traitement. reduce : permet de réduire l’ensemble des éléments à une seule valeur grâce à l’utilisation d’un accumulateur. JavaScript fournit depuis ES5 les méthodes Array.filter, Array.map et Array.reduce qui attendent toutes en paramètre une fonction à appliquer pour chaque élément du tableau.\nSi on désire filtrer les éléments d’un tableau pour créer un autre tableau, on peut utiliser la méthode Array.filter.\nlet t = [1, 2, 3, 4]; let odds = t.filter(x =\u003e x % 2); console.log(odds); // Affiche [1, 3] Si on veut modifier les éléments d’un tableau en créant un nouveau tableau, on peut utiliser la méthode Array.map. Le code ci-dessous, permet de créer un tableau de nombres à partir d’un tableau de chaînes de caractères.\nlet t = [\"2\", \"101\", \"324\"]; let numbers = t.map(x =\u003e parseInt(x, 10)); console.log(numbers); // Affiche [2, 101, 324] Si on veut créer un résultat unique à partir d’un tableau, on peut utiliser la méthode Array.reduce. Cette dernière attend en paramètre une fonction qui prend deux paramètres : l’élément courant et l’élément résultat de l’appel précédent. On parle d’une fonction accumulatrice.\nlet t = [1, 2, 3]; let result = t.reduce((a, b) =\u003e a + b); console.log(result); // Affiche 6 On peut chaîner ces méthodes pour obtenir des traitements complexes.\nlet celsius = [0, 12, -2, 6, -18, 32]; let min_farenheit = celsius.filter(x =\u003e x \u003e 0) .map(x =\u003e 1.8 * x + 32) .reduce((x, y) =\u003e x \u003c y ? x : y); console.log(min_farenheit); // Affiche 48.8 Le code ci-dessous parcourt un tableau de températures en degré Celsius. On élimine les températures négatives ou égales à zéro, puis on transforme les températures en degré Fahrenheit. Enfin, on conserve la température minimale par réduction. Donc, on affiche la température en degré Fahrenheit qui est la plus petite mais qui est positive.",
    "description": "Définition La programmation fonctionnelle est un paradigme de programmation qui insiste sur l’évaluation d’appel de fonctions plutôt que sur l’utilisation de variables et de blocs imbriqués (for, if…).\nLes fonctions ont toujours été des objets de plein droit en JavaScript. Il est par exemple possible de créer des fonctions anonymes et de les affecter à des variables ou de les passer en paramètre d’autres fonctions.\nImpératif vs déclaratif La programmation fonctionnelle fait partie d’un paradigme de programmation plus large : la programmation déclarative.",
    "tags": [],
    "title": "Programmation fonctionnelle",
    "uri": "/0-intro/6-prog-fonctionnelle/index.html"
  },
  {
    "breadcrumb": "Préalables",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Git/GitHub",
    "uri": "/0-intro/7-git-github/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Préalables",
    "uri": "/0-intro/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
